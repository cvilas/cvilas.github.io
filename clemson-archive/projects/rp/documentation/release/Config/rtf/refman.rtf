{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title Config Class Reference Manual}
{\author Generated by Doxygen}
{\creatim \yr2001\mo7\dy19\hr12\min42\sec20}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\pard\plain 
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Config Class Compound Index\par \pard\plain 
{\tc \v Compound Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Config Class Compound List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b Config}  (Utility class to read and write ASCII configuration files)\tab {\field\fldedit {\*\fldinst PAGEREF class_Config \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par
}\sect \sbkpage \pgnrestart
\sect \sectd \sbknone \pgndec
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Config Class Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Config  Class Reference\par \pard\plain 
{\tc\tcl2 \v Config}
{\xe \v Config}
{\bkmkstart class_Config}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Utility class to read and write ASCII configuration files. 
\par
{\f2 #include <Config.hpp>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b errorCodes} \{ {\b e_cantFindSection} = 10, 
{\b e_newFailed}, 
{\b e_cantFindEntry}
 \}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Config} (const char *configFileNameAndPath=0, const char *searchPathShellVariable="CONFIG")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Config} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFileName} (const char *fileName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char* {\b getFileName} (void) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSearchPathShellVariable} (const char *searchPathShellVariable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char* {\b getSearchPathShellVariable} (void) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char* {\b getResolvedConfigFullPath} (void) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loadConfiguration} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b saveConfiguration} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b disableAutoSave} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enableAutoSave} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createSection} (const char *sectionName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearSection} (const char *sectionName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deleteSection} (const char *sectionName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCurrentSectionName} (const char *sectionName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char* {\b getCurrentSectionName} (void) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getNumSections} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char* {\b getSectionNameByIndex} (int i)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enableAutoClearStatus} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b disableAutoClearStatus} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isAutoClearStatusEnabled} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<classT> void {\b setEntry} (const char *entryName, T value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<classT> void {\b setEntry} (const char *sectionName, const char *entryName, T value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<classT> void {\b getEntry} (const char *entryName, T &value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<classT> void {\b getEntry} (const char *sectionName, const char *entryName, T &value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getIntegerEntry} (const char *entryName, int defaultValue = 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getIntegerEntry} (const char *sectionName, const char *entryName, int defaultValue = 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getDoubleEntry} (const char *entryName, double defaultValue = 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getDoubleEntry} (const char *sectionName, const char *entryName, double defaultValue = 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char* {\b getStringEntry} (const char *entryName, const char *defaultValue = 0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char* {\b getStringEntry} (const char *sectionName, const char *entryName, const char *defaultValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<classT> void {\b getArrayEntry} (const char *entryName, T *data, int rows = 1, int cols = 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<classT> void {\b getArrayEntry} (const char *sectionName, const char *entryName, T *data, int rows = 1, int cols = 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<classT> void {\b setArrayEntry} (const char *entryName, T *value, int rows = 1, int cols = 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<classT> void {\b setArrayEntry} (const char *sectionName, const char *entryName, T *value, int rows = 1, int cols = 1)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Status {\b d_status}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Utility class to read and write ASCII configuration files.\par
\par
The Config class provides a mechanism for reading and writing configuration files. Configuration files are ASCII files that contain an optional global section and subsequent named sections.\par
Configuration files are case sensitive. The elements of a config file are listed as follows:\par
Section Name (the name is enclosed in square brackets).\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  [MySectionName]\par
}
Blank lines (these are skipped).\par
Entries (begin with an alphanumeric identifier that conforms to C identifier name rules, values appear after the identifier)\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  mainWindowSize 30 40\line
 mainWindowPosition 20 10\par
}
Below is an example configuration file:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  age 30\line
 name Nick\line
 occupation Lifetime Student\line
 address 315 EIB\line
 address0 Fluor Daniel Engineering Innovation Bldg\line
 city Clemson\line
 hours 8 4 3 4 2 3\line
 testMatrix3by2 1 2 3 4 5 6\line
 \line
 [Tooner]\line
 age 7\line
 name Tooner\line
 occupation Pet\line
 address 123 Cat Row\line
 city New York\line
 \line
 [Stinky]\line
 age 5\line
 name Stinky\line
 occupation Pet\line
 address 234 Cat Row\line
 city Chicago\par
}
{\b Example Program:}\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid //========================================================================\line
// Project: QRTS Utility Classes\line
// ----------------------------------------------------------------------\line
// Package: Config\line
// Authors: Nick Costescu, Markus Loffler\line
// ----------------------------------------------------------------------\line
// File: Config.t.cpp\line
// Example program for the Config class.\line
//========================================================================\line
\line
#include "Config.hpp"\line
\line
#include <iostream.h>\line
#include <stdio.h>\line
#include <string.h>\line
\line
\line
//========================================================================\line
// Global Variables\line
//========================================================================\line
\line
const int c_numPersons = 3;\line
char name[c_numPersons][200];\line
int age[c_numPersons];\line
\line
Config *myConfig;\line
\line
\line
//========================================================================\line
// loadConfiguration\line
//========================================================================\line
\line
void loadConfiguration()\line
\{\line
  // Load the configuration from the file\line
  myConfig->loadConfiguration ();\line
  if (myConfig->d_status.isStatusError ())\line
  \{\line
    cout << myConfig->d_status.getMessageText () << endl;\line
    return;\line
  \}\line
\line
  // Get the entries\line
  for (int i = 0; i < 3; i++)\line
  \{\line
    // Set section\line
    char sectionName[200];\line
    sprintf(sectionName, "Person%d", i);\line
    myConfig->setCurrentSectionName(sectionName);\line
    \line
    // Read entries\line
    strcpy(name[i], myConfig->getStringEntry("name", "default"));\line
    age[i] = myConfig->getIntegerEntry("age", 20);\line
  \}\line
\}\line
\line
\line
//========================================================================\line
// saveConfiguration\line
//========================================================================\line
\line
void saveConfiguration()\line
\{\line
  cout << "Saving configuration" << endl;\line
\line
  // Set the entries\line
  for (int i = 0; i < 3; i++)\line
  \{\line
    // Set section\line
    char sectionName[200];\line
    sprintf(sectionName, "Person%d", i);\line
    myConfig->setCurrentSectionName(sectionName);\line
    \line
    // Read entries\line
    myConfig->setEntry("name", name[i]);\line
    myConfig->setEntry("age", age[i]);\line
  \}\line
  \line
  myConfig->saveConfiguration();\line
\}\line
\line
\line
//========================================================================\line
// main\line
//========================================================================\line
\line
int main ()\line
\{\line
  myConfig = new Config("Config.t.cfg");\line
  myConfig->disableAutoSave();\line
  \line
  loadConfiguration();\line
  \line
  while (1)\line
  \{\line
    cout << endl;\line
    cout << "---- Current List of Persons ----" << endl;\line
    for (int i = 0; i < 3; i++)\line
      cout << "Person " << i + 1 << ": Name " << name[i] << ", age " << age[i] << endl;\line
    cout << endl;\line
    cout << "Change which person (0 to exit): ";\line
    int num;\line
    cin >> num;\line
    if (num == 0)\line
      break;\line
    \line
    cout << "New name: ";\line
    cin >> name[num - 1];\line
    cout << "New age: ";\line
    cin >> age[num - 1];  \line
  \}\line
  \line
  cout << endl;\line
  cout << "Save configuration? (yes, no)" << endl;\line
  char input[20];\line
  cin >> input;\line
  if (strcmp(input, "yes") == 0)\line
    saveConfiguration();\line
\line
  delete myConfig;\line
    \line
  return 0;\line
\}\line
\par
}
 \par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v errorCodes\:Config}
{\xe \v Config\:errorCodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum errorCodes}
}\par
{\bkmkstart class_Config_s3}
{\bkmkend class_Config_s3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
These are the error codes {\i {\b d_status}} is set to in case of certain errors. \par
{\par
{\b Enumeration values:}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\xe \v e_cantFindSection\:Config}
{\xe \v Config\:e_cantFindSection}
{\b {\i e_cantFindSection}{\bkmkstart class_Config_s3s0}
{\bkmkend class_Config_s3s0}
}  A section was not found. \par
{\xe \v e_newFailed\:Config}
{\xe \v Config\:e_newFailed}
{\b {\i e_newFailed}{\bkmkstart class_Config_s3s1}
{\bkmkend class_Config_s3s1}
}  An operation was out of memory \par
{\xe \v e_cantFindEntry\:Config}
{\xe \v Config\:e_cantFindEntry}
{\b {\i e_cantFindEntry}{\bkmkstart class_Config_s3s2}
{\bkmkend class_Config_s3s2}
}  An entry name was not found. \par
}
\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Config\:Config}
{\xe \v Config\:Config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Config (const char * {\i configFileNameAndPath} = 0, const char * {\i searchPathShellVariable} = "CONFIG")}
}\par
{\bkmkstart class_Config_a0}
{\bkmkend class_Config_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The constructor initializes the configuratin file name  (if given) and the search path shell variable (if given). See {\b setFileName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}) and {\b setSearchPathShellVariable}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}) for more information about these parameters. The constructor does not load the configuration, this must be explicitly done by calling {\b loadConfiguration}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}). If the configuration file name is not specified, {\b setFileName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}) needs to be called before loading the configuration with {\b loadConfiguration}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        Config *myConfig;\line
       \line
      myConfig = new Config ("test.cfg", "CONFIG");\par
}
 \par
}
{\xe \v ~Config\:Config}
{\xe \v Config\:~Config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
~Config ()}
}\par
{\bkmkstart class_Config_a1}
{\bkmkend class_Config_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The default behavior of the destructor  is to save the current configuration to the currently specified configuration file. The {\b disableAutoSave}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}) method can be used to disable this default behavior (in this case the user must explicitly call {\b saveConfiguration}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}) to save the configuration file). If you have not specified a current config file name (with {\b setFileName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}) or with the constructor), the file will not be saved.\par
{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        delete myConfig;\par
}
 \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v setFileName\:Config}
{\xe \v Config\:setFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setFileName (const char * {\i fileName})}
}\par
{\bkmkstart class_Config_a2}
{\bkmkend class_Config_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets the name of the configuration file. Subsequent load or save functions will deal with this file. If you don't specify a path here (i.e., the filename does not contain a "/" character), then the shell search path variable (specified with {\b setSearchPathShellVariable}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}) with in the constructor) will be used to resolve the full path. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i fileName}}   The filename of the configuration file\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->setFileName("myconfigurationfile.cfg");\par
}
 \par
}
{\xe \v getFileName\:Config}
{\xe \v Config\:getFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * getFileName (void) const}
}\par
{\bkmkstart class_Config_a3}
{\bkmkend class_Config_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets the name of the configuration file. {\par
{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The name of the configuration file.\par
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        cout << myConfig->getFileName();\par
}
 \par
}
{\xe \v setSearchPathShellVariable\:Config}
{\xe \v Config\:setSearchPathShellVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setSearchPathShellVariable (const char * {\i searchPathShellVariable})}
}\par
{\bkmkstart class_Config_a4}
{\bkmkend class_Config_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets the name of the shell variable that contains the search path for config files. Subsequent load or save functions will use this path to find the config file, if only a file name was specified with {\b setFileName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}) (or with the constructor). The search path contains the absolute paths of all search directories, separated by ":". {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i searchPathShellVariable}}   The name of the search path shell variable.\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        // Look for the configuration files in the search path for binaries\line
       myConfig->setSearchPathShellVariable("PATH");\par
}
 \par
}
{\xe \v getSearchPathShellVariable\:Config}
{\xe \v Config\:getSearchPathShellVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * getSearchPathShellVariable (void) const}
}\par
{\bkmkstart class_Config_a5}
{\bkmkend class_Config_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets the name of the shell variable that contains the search path for config files. {\par
{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The name of the search path shell variable\par
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        cout << myConfig->getSearchPathShellVariable();\par
}
 \par
}
{\xe \v getResolvedConfigFullPath\:Config}
{\xe \v Config\:getResolvedConfigFullPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * getResolvedConfigFullPath (void) const}
}\par
{\bkmkstart class_Config_a6}
{\bkmkend class_Config_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets a pointer to the resolved full path to the config file. If the user specified a path (including a file name) for the config file name, then that path (including the file name) is returned here. If the user specified only a file name, then  the search path shell variable (given in the constructor or specified with {\b setSearchPathShellVariable}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}})) is set to) is used to find the config file. If the file is found, this resolved full path will have all of the path in it including the file name. If a config shell search path variable is not specified, the config file name will be returned. {\par
{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The resolved path of the configuration file.\par
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->setFileName ("test.cfg");\line
       myConfig->setSearchPathShellVariable ("CONFIG");\line
      cout << getResolvedConfigFullPath() << endl;\par
}
If the shell variable CONFIG was set to ".:/usr/qrts/config", and there was no "test.cfg" file in the current directory, but there was one in "/usr/qrts/config", this method would return the string "/usr/qrts/config/test.cfg".\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->setFileName ("/test.cfg");\line
       myConfig->setSearchPathShellVariable ("CONFIG");\line
      cout << getResolvedConfigFullPath() << endl;\par
}
Will output "/test.cfg" regardless of what CONFIG is set to because a path is specified with {\b setFileName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}). \par
}
{\xe \v loadConfiguration\:Config}
{\xe \v Config\:loadConfiguration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void loadConfiguration (void)}
}\par
{\bkmkstart class_Config_a7}
{\bkmkend class_Config_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Loads the configuration. File name and search path (if used) must be set prior to this function being called. If the name is not set, or the file can't be found, d_status will be set to error. Configuration items in memory will be overwritten by ones read from the file.\par
{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->loadConfiguration();\line
       \line
       if (myConfig->d_status.isStatusError())\line
       \{\line
         cerr << "Can't load configuration file " << \line
           myConfig->getResolvedConfigFullPath() << endl;\line
         abort();\line
      \}\par
}
 \par
}
{\xe \v saveConfiguration\:Config}
{\xe \v Config\:saveConfiguration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void saveConfiguration (void)}
}\par
{\bkmkstart class_Config_a8}
{\bkmkend class_Config_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Saves the configuration. File name must be set prior to this function being called. If the name is not set, d_status will be set to error. The file will be saved to whatever full path is returned by {\b getResolvedConfigFullPath}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->saveConfiguration();\line
       \line
       if (myConfig->d_status.isStatusError())\line
       \{\line
         cerr << "Can't save configuration to file "\line
              << config->getResolvedConfigFullPath() << endl;\line
         abort();\line
      \}\par
}
 \par
}
{\xe \v clear\:Config}
{\xe \v Config\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clear ()}
}\par
{\bkmkstart class_Config_a9}
{\bkmkend class_Config_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Clears and deletes all sections and entries.\par
{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->clear();\par
}
 \par
}
{\xe \v disableAutoSave\:Config}
{\xe \v Config\:disableAutoSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void disableAutoSave (void)}
}\par
{\bkmkstart class_Config_a10}
{\bkmkend class_Config_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Disables auto saving when the object is deleted. If disabled, you must explicitly save the configuration before deletion of the object. The default setting is enabled.\par
{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->disableAutoSave();\par
}
 \par
}
{\xe \v enableAutoSave\:Config}
{\xe \v Config\:enableAutoSave}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void enableAutoSave (void)}
}\par
{\bkmkstart class_Config_a11}
{\bkmkend class_Config_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enables auto saving when the object is deleted. If you do this, the configuration will automatically be saved to the currently specified file name when the object is deleted. The default setting is enabled.\par
{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->enableAutoSave();\par
}
 \par
}
{\xe \v createSection\:Config}
{\xe \v Config\:createSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void createSection (const char * {\i sectionName})}
}\par
{\bkmkstart class_Config_a12}
{\bkmkend class_Config_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Creates a new section at the end of the configuration. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   Name of the section to be created. If not specified, the default/global section is used.\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->createSection ("Bob");\par
}
 \par
}
{\xe \v clearSection\:Config}
{\xe \v Config\:clearSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void clearSection (const char * {\i sectionName})}
}\par
{\bkmkstart class_Config_a13}
{\bkmkend class_Config_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes all entries in the given section in memory. Does not delete the section itself. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   Name of the section to be cleared. If not specified, the default/global section is used.\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->clearSection ("Tooner");\par
}
 \par
}
{\xe \v deleteSection\:Config}
{\xe \v Config\:deleteSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void deleteSection (const char * {\i sectionName})}
}\par
{\bkmkstart class_Config_a14}
{\bkmkend class_Config_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes a section and all entries in it. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   Name of the section to be deleted. If not specified, the default/global section is used.\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->deleteSection ("Bob");\par
}
 \par
}
{\xe \v setCurrentSectionName\:Config}
{\xe \v Config\:setCurrentSectionName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setCurrentSectionName (const char * {\i sectionName})}
}\par
{\bkmkstart class_Config_a15}
{\bkmkend class_Config_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets the current section name. This name is used for all get/set entry methods that do not specify a section. By default, this is set to "global" by the constructor. Use the special name "global" to address the global section. {\par
{\b Warning: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  {\b Using this function in combination with any of the set..Entry(const char *entry, ...) and / get...Entry(const char *entry, ...) functions is not thread-safe. Instead, set..Entry(const char *section, const char *entry, ...) and / get...Entry(const char *section, const char *entry, ...) should be used in threaded programs.\par
}{{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   Name of the section to make current.\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        myConfig->setCurrentSection ("Tooner");\par
}
 \par
}
{\xe \v getCurrentSectionName\:Config}
{\xe \v Config\:getCurrentSectionName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * getCurrentSectionName (void) const}
}\par
{\bkmkstart class_Config_a16}
{\bkmkend class_Config_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets the name of the current section (to which all reads/writes pertain).\par
{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        cout << myConfig->getCurrentSectionName();\par
}
 \par
}
{\xe \v getNumSections\:Config}
{\xe \v Config\:getNumSections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int getNumSections (){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a17}
{\bkmkend class_Config_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the number of sections. {\par
{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The number of sections. \par
}}
{\xe \v getSectionNameByIndex\:Config}
{\xe \v Config\:getSectionNameByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * getSectionNameByIndex (int {\i i}){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a18}
{\bkmkend class_Config_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a section name. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i i}}   Index of the section (0 = "global" section). \par
}
\par
}{{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The section name. \par
}{{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i <b>Example:<}}  /b>\par
\par
}
\par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        cout << "List of all sections: " << endl;\line
       for (int i = 0; i < myConfig->getNumSections(); i++)\line
        cout << i << " " << myConfig->getSectionNameByIndex(i) << endl;\par
}
 \par
}
{\xe \v enableAutoClearStatus\:Config}
{\xe \v Config\:enableAutoClearStatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void enableAutoClearStatus (){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a19}
{\bkmkend class_Config_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enables the auto clear status feature. If this feature is enabled, d_status is automatically set to "OK" before each get...Entry()/set...Entry() function. The default is off. \par
}
{\xe \v disableAutoClearStatus\:Config}
{\xe \v Config\:disableAutoClearStatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void disableAutoClearStatus (){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a20}
{\bkmkend class_Config_a20}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Disables the auto clear status feature. If this feature is enabled, d_status is automatically set to "OK" before each get...Entry()/set...Entry() function. The default is off. \par
}
{\xe \v isAutoClearStatusEnabled\:Config}
{\xe \v Config\:isAutoClearStatusEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int isAutoClearStatusEnabled () const{\f2  [inline]}}
}\par
{\bkmkstart class_Config_a21}
{\bkmkend class_Config_a21}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns if the auto clear status feature is enabled. If this feature is enabled, d_status is automatically set to "OK" before each get...Entry()/set...Entry() function. The default is off. \par
}
{\xe \v setEntry\:Config}
{\xe \v Config\:setEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEntry (const char * {\i entryName}, T {\i value}){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a22}
{\bkmkend class_Config_a22}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets a scalar entry of type T in the section that is specified by {\b setCurrentSectionName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}). If the section does not exist, it is automatically created.{\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i entryName}}   The name of the entry. \par
{\b {\i value}}   Value to set the entry to.\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        config->setEntry("encoder", 120);\par
}
 \par
}
{\xe \v setEntry\:Config}
{\xe \v Config\:setEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setEntry (const char * {\i sectionName}, const char * {\i entryName}, T {\i value})}
}\par
{\bkmkstart class_Config_a23}
{\bkmkend class_Config_a23}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets a scalar entry of type T in a specified section. If the section does not exist, it is automatically created.{\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   The name of the section. \par
{\b {\i entryName}}   The name of the entry. \par
{\b {\i value}}   Value to set the entry to.\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        config->setEntry("encoder", 120);\par
}
 \par
}
{\xe \v getEntry\:Config}
{\xe \v Config\:getEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getEntry (const char * {\i entryName}, T & {\i value}){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a24}
{\bkmkend class_Config_a24}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets a scalar entry of type T in the section that is specified by {\b setCurrentSectionName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}). {\par
{\b See also: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The convenience functions {\b getIntegerEntry}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a26 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b getDoubleEntry}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a28 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b getStringEntry}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a30 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}{{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i entryName}}   The name of the entry. \par
{\b {\i value}}   Value is set from the entry.\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        unsigned short int encoder;\line
       config->getEntry("encoder", encoder);\par
}
 \par
}
{\xe \v getEntry\:Config}
{\xe \v Config\:getEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getEntry (const char * {\i sectionName}, const char * {\i entryName}, T & {\i value})}
}\par
{\bkmkstart class_Config_a25}
{\bkmkend class_Config_a25}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets a scalar entry of type T in a specified section. {\par
{\b See also: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The convenience functions {\b getIntegerEntry}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a26 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b getDoubleEntry}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a28 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b getStringEntry}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a30 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}{{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   The name of the section. \par
{\b {\i entryName}}   The name of the entry. \par
{\b {\i value}}   Value is set from the entry.\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        unsigned short int encoder;\line
       config->getEntry("encoder", encoder);\par
}
 \par
}
{\xe \v getIntegerEntry\:Config}
{\xe \v Config\:getIntegerEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int getIntegerEntry (const char * {\i entryName}, int {\i defaultValue} = 0){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a26}
{\bkmkend class_Config_a26}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets a scalar integer entry in the section that is specified by {\b setCurrentSectionName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}). If the entry is not there, d_status is set to error. If the status is error, the default value is returned. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i entryName}}   Name of the entry to be read. \par
{\b {\i defaultValue}}   This value is returned if the value cannot be  read from the configuration. \par
}
\par
}{{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The entry value.\par
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        int fillColor = config->getIntegerEntry("fillColor", 0);\line
       if (config->d_status.isStatusError())\line
       \{\line
         cout << "An error occurred reading entry fillColor "\line
              << config->d_status.getMessageText() << endl;\line
      \}\par
}
 \par
}
{\xe \v getIntegerEntry\:Config}
{\xe \v Config\:getIntegerEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int getIntegerEntry (const char * {\i sectionName}, const char * {\i entryName}, int {\i defaultValue} = 0)}
}\par
{\bkmkstart class_Config_a27}
{\bkmkend class_Config_a27}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets a scalar integer entry of a specified section. If the entry is not there, d_status is set to error. If the status is error, the default value is returned. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   The name of the section. \par
{\b {\i entryName}}   Name of the entry to be read. \par
{\b {\i defaultValue}}   This value is returned if the value cannot be  read from the configuration. \par
}
\par
}{{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The entry value. \par
}}
{\xe \v getDoubleEntry\:Config}
{\xe \v Config\:getDoubleEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double getDoubleEntry (const char * {\i entryName}, double {\i defaultValue} = 0){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a28}
{\bkmkend class_Config_a28}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets a scalar double entry in the section that is specified by {\b setCurrentSectionName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}). If the entry is not there, d_status is set to error. If the status is error, the default value is returned. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i entryName}}   Name of the entry to be read. \par
{\b {\i defaultValue}}   This value is returned if the value cannot be  read from the configuration. \par
}
\par
}{{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The entry value. \par
}}
{\xe \v getDoubleEntry\:Config}
{\xe \v Config\:getDoubleEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double getDoubleEntry (const char * {\i sectionName}, const char * {\i entryName}, double {\i defaultValue} = 0)}
}\par
{\bkmkstart class_Config_a29}
{\bkmkend class_Config_a29}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets a scalar double entry in the specified section. If the entry is not there, d_status is set to error. If the status is error, the default value is returned.{\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i entryName}}   Name of the entry to be read. \par
{\b {\i defaultValue}}   This value is returned if the value cannot be  read from the configuration. \par
}
\par
}{{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The entry value. \par
}}
{\xe \v getStringEntry\:Config}
{\xe \v Config\:getStringEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * getStringEntry (const char * {\i entryName}, const char * {\i defaultValue} = 0){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a30}
{\bkmkend class_Config_a30}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets a scalar string entry in the section that is specified by {\b setCurrentSectionName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}). If the entry is not there, d_status is set to error. If the status is error, the default value is returned. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i entryName}}   Name of the entry to be read. \par
{\b {\i defaultValue}}   This value is returned if the value cannot be  read from the configuration. \par
}
\par
}{{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The entry value. \par
}}
{\xe \v getStringEntry\:Config}
{\xe \v Config\:getStringEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * getStringEntry (const char * {\i sectionName}, const char * {\i entryName}, const char * {\i defaultValue})}
}\par
{\bkmkstart class_Config_a31}
{\bkmkend class_Config_a31}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets a scalar string entry in specified section. If the entry is not there, d_status is set to error. If the status is error, the default value is returned. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   The name of the section. \par
{\b {\i entryName}}   Name of the entry to be read. \par
{\b {\i defaultValue}}   This value is returned if the value cannot be  read from the configuration. \par
}
\par
}{{\b Returns: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  The entry value. \par
}}
{\xe \v getArrayEntry\:Config}
{\xe \v Config\:getArrayEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getArrayEntry (const char * {\i entryName}, T * {\i data}, int {\i rows} = 1, int {\i cols} = 1){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a32}
{\bkmkend class_Config_a32}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets the given array from the configuration in the section that is specified by {\b setCurrentSectionName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}). You must allocate the memory for the array. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i entryName}}   Name of the entry to be read. \par
{\b {\i data}}   Pointer to memory you've allocated to store the array. \par
{\b {\i rows}}   Number of rows in the array (default = 1). \par
{\b {\i cols}}   Number of columns in the array (default = 1).\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        double matrix[3][3];\line
      config->getArrayEntry("myMatrix", matrix, 3, 3);\par
}
 \par
}
{\xe \v getArrayEntry\:Config}
{\xe \v Config\:getArrayEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getArrayEntry (const char * {\i sectionName}, const char * {\i entryName}, T * {\i data}, int {\i rows} = 1, int {\i cols} = 1)}
}\par
{\bkmkstart class_Config_a33}
{\bkmkend class_Config_a33}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gets the given array from the configuration in the specified section. You must allocate the memory for the array. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   The name of the section. \par
{\b {\i entryName}}   Name of the entry to be read. \par
{\b {\i data}}   Pointer to memory you've allocated to store the array. \par
{\b {\i rows}}   Number of rows in the array (default = 1). \par
{\b {\i cols}}   Number of columns in the array (default = 1). \par
}
\par
}}
{\xe \v setArrayEntry\:Config}
{\xe \v Config\:setArrayEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setArrayEntry (const char * {\i entryName}, T * {\i value}, int {\i rows} = 1, int {\i cols} = 1){\f2  [inline]}}
}\par
{\bkmkstart class_Config_a34}
{\bkmkend class_Config_a34}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets the given array from the configuration in the section that is specified by {\b setCurrentSectionName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF class_Config_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}).  {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i entryName}}   Name of the entry to be set. \par
{\b {\i data}}   Pointer to memory where the values are stored. \par
{\b {\i rows}}   Number of rows in the array (default = 1). \par
{\b {\i cols}}   Number of columns in the array (default = 1).\par
\par
}
\par
}{\b Example:}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid        double matrix[3][3];\line
      config->getArrayEntry("myMatrix", matrix, 3, 3);\par
}
 \par
}
{\xe \v setArrayEntry\:Config}
{\xe \v Config\:setArrayEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setArrayEntry (const char * {\i sectionName}, const char * {\i entryName}, T * {\i value}, int {\i rows} = 1, int {\i cols} = 1)}
}\par
{\bkmkstart class_Config_a35}
{\bkmkend class_Config_a35}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets the given array from the configuration  in the specified section. {\par
{\b Parameters: }\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {
{\b {\i sectionName}}   The name of the section. \par
{\b {\i entryName}}   Name of the entry to be set. \par
{\b {\i data}}   Pointer to memory where the values are stored. \par
{\b {\i rows}}   Number of rows in the array (default = 1). \par
{\b {\i cols}}   Number of columns in the array (default = 1). \par
}
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v d_status\:Config}
{\xe \v Config\:d_status}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Status d_status}
}\par
{\bkmkstart class_Config_m0}
{\bkmkend class_Config_m0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Used for error messages and status information. Note: For all of the get.../set... functions below that get/set scalar values, d_status is set to error in case the entry was not found. This won t affect further calls to the get.../set... functions (but d_status won t be reset to "ok"). After using a get...() function, the user should check d_status to see if there was an error which indicates the entry did not exist or was invalid. \par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Config.hpp}\par
}}

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}