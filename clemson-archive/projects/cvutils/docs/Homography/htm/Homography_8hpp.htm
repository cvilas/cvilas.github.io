<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Homography Library: Homography.hpp File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.htm"><span>Classes</span></a></li>
    <li id="current"><a href="files.htm"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.htm"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.htm"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>Homography.hpp File Reference</h1><code>#include &quot;QMath/Vector.hpp&quot;</code><br>
<code>#include &quot;QMath/RowVector.hpp&quot;</code><br>
<code>#include &quot;QMath/GSLCompat.hpp&quot;</code><br>
<code>#include &lt;gsl/gsl_linalg.h&gt;</code><br>
<code>#include &lt;gsl/gsl_combination.h&gt;</code><br>
<code>#include &lt;gsl/gsl_cblas.h&gt;</code><br>
<code>#include &lt;gsl/gsl_blas.h&gt;</code><br>
<code>#include &lt;gsl/gsl_eigen.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>

<p>
<a href="Homography_8hpp-source.htm">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__motion__params.htm">_motion_params</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Motion parameters that define a homography matrix.  <a href="struct__motion__params.htm#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProjectiveHomography.htm">ProjectiveHomography</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Homography computation functions.  <a href="classProjectiveHomography.htm#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="struct__motion__params.htm">_motion_params</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="Homography_8hpp.htm#1f43cb8d0985c855f02e264e4ceb32d0">motion_params_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef enum <a class="el" href="Homography_8hpp.htm#cfa45228be0853f4379c8272f0014dcb">_homography_method</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="Homography_8hpp.htm#10939b2ed3156d5eacdaa3a347f7f19c">homography_method_t</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="Homography_8hpp.htm#cfa45228be0853f4379c8272f0014dcb">_homography_method</a> { <a class="el" href="Homography_8hpp.htm#cfa45228be0853f4379c8272f0014dcbd9c929b120cf4df9153e5e4b37ab6043">e_ls</a> =  1, 
<a class="el" href="Homography_8hpp.htm#cfa45228be0853f4379c8272f0014dcbc569dd4d7f662f480d7b3ce60bc9bbac">e_kk</a>, 
<a class="el" href="Homography_8hpp.htm#cfa45228be0853f4379c8272f0014dcb8aca0e3f1fbf86b297369db21dc6e5d3">e_vp</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method used to compute homography matrix.  <a href="Homography_8hpp.htm#cfa45228be0853f4379c8272f0014dcb">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="Homography_8hpp.htm#98c65fd6d68200dc8d9538bdbc79c7c8">decomposeHomography</a> (const Matrix&lt; 3, 3 &gt; &amp;Hen, <a class="el" href="struct__motion__params.htm">motion_params_t</a> &amp;motion0, <a class="el" href="struct__motion__params.htm">motion_params_t</a> &amp;motion1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="Homography_8hpp.htm#44c8d186984bb7434267c237f86eeed7">decomposeHomography</a> (const Matrix&lt; 3, 3 &gt; &amp;Hen, const Vector&lt; 3 &gt; &amp;n, <a class="el" href="struct__motion__params.htm">motion_params_t</a> &amp;motion)</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="1f43cb8d0985c855f02e264e4ceb32d0"></a><!-- doxytag: member="Homography.hpp::motion_params_t" ref="1f43cb8d0985c855f02e264e4ceb32d0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct <a class="el" href="struct__motion__params.htm">_motion_params</a> <a class="el" href="struct__motion__params.htm">motion_params_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="10939b2ed3156d5eacdaa3a347f7f19c"></a><!-- doxytag: member="Homography.hpp::homography_method_t" ref="10939b2ed3156d5eacdaa3a347f7f19c" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef enum <a class="el" href="Homography_8hpp.htm#cfa45228be0853f4379c8272f0014dcb">_homography_method</a> <a class="el" href="Homography_8hpp.htm#10939b2ed3156d5eacdaa3a347f7f19c">homography_method_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="cfa45228be0853f4379c8272f0014dcb"></a><!-- doxytag: member="Homography.hpp::_homography_method" ref="cfa45228be0853f4379c8272f0014dcb" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="Homography_8hpp.htm#cfa45228be0853f4379c8272f0014dcb">_homography_method</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method used to compute homography matrix. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="cfa45228be0853f4379c8272f0014dcbd9c929b120cf4df9153e5e4b37ab6043"></a><!-- doxytag: member="e_ls" ref="cfa45228be0853f4379c8272f0014dcbd9c929b120cf4df9153e5e4b37ab6043" args="" -->e_ls</em>&nbsp;</td><td>
least squares method (for coplanar features) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cfa45228be0853f4379c8272f0014dcbc569dd4d7f662f480d7b3ce60bc9bbac"></a><!-- doxytag: member="e_kk" ref="cfa45228be0853f4379c8272f0014dcbc569dd4d7f662f480d7b3ce60bc9bbac" args="" -->e_kk</em>&nbsp;</td><td>
Kanatani optimal algorithm (for coplanar features). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="cfa45228be0853f4379c8272f0014dcb8aca0e3f1fbf86b297369db21dc6e5d3"></a><!-- doxytag: member="e_vp" ref="cfa45228be0853f4379c8272f0014dcb8aca0e3f1fbf86b297369db21dc6e5d3" args="" -->e_vp</em>&nbsp;</td><td>
Virtual parallax method (Malis) (for non-coplanar features). </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="98c65fd6d68200dc8d9538bdbc79c7c8"></a><!-- doxytag: member="Homography.hpp::decomposeHomography" ref="98c65fd6d68200dc8d9538bdbc79c7c8" args="(const Matrix&lt; 3, 3 &gt; &amp;Hen, motion_params_t &amp;motion0, motion_params_t &amp;motion1)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int decomposeHomography           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Matrix&lt; 3, 3 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Hen</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct__motion__params.htm">motion_params_t</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>motion0</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct__motion__params.htm">motion_params_t</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>motion1</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Decompose a <b>Euclidean</b> homography to obtain the motion parameters. Two physically possible solutions are returned. If the unit normal vector is known (see class description), the solution to decomposition is unique, in which case use the subsequent method with the same name to compute the motion parameters more accurately. <hr>
<br>
 IMPORTANT NOTE: This method does not produce valid solutions when there is no motion, or when the motion between camera frames is a pure rotation. <br>
<hr>
 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Hen</em>&nbsp;</td><td>The normalized Euclidean homography [Hen = inverse(C) * Hpn * C, where C is the camera intrinsic calibration matrix] (input). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>motion0</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>motion1</em>&nbsp;</td><td>The two physically possible solutions (output). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="44c8d186984bb7434267c237f86eeed7"></a><!-- doxytag: member="Homography.hpp::decomposeHomography" ref="44c8d186984bb7434267c237f86eeed7" args="(const Matrix&lt; 3, 3 &gt; &amp;Hen, const Vector&lt; 3 &gt; &amp;n, motion_params_t &amp;motion)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int decomposeHomography           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Matrix&lt; 3, 3 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Hen</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const Vector&lt; 3 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct__motion__params.htm">motion_params_t</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>motion</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If the unit normal vector is known, this method can be used to decompose <b>Euclidean</b> homography more accurately than the previous method with the same name. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Hen</em>&nbsp;</td><td>The normalized Euclidean homography [Hen = inverse(C) * Hpn * C, where C is the camera intrinsic calibration matrix] (input). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The known unit normal vector (see class description) (input). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>motion</em>&nbsp;</td><td>The motion parameters from homography decomposition (output) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>
    </td>
  </tr>
</table>
<hr>
Created for project <code><font color="red"><b>test</b></font></code> on Sat Aug 26 14:52:11 EDT 2006
<br>
 for Vilas Kumar Chitrakaran (cvilas(@)ces.clemson.edu). 
<br>
Documentation generated using <a href=http://www.doxygen.org>Doxygen</a>
.
</body>
</html>
