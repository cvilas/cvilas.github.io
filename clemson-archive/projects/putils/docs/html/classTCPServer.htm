<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>POSIX Utilities Package 2.2: TCPServer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.htm"><span>Classes</span></a></li>
    <li><a href="files.htm"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.htm"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.htm"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.htm"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>TCPServer Class Reference</h1><!-- doxytag: class="TCPServer" -->This is the server part of the TCPServer/TCPClient pair.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="TCPClientServer_8hpp-source.htm">TCPClientServer.hpp</a>&gt;</code>
<p>
<a href="classTCPServer-members.htm">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#3a5e3cfe42c676ed71f2bc58dcc92bda">TCPServer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#5fde4bdcdc8f2bf8c7f548edf7a8260a">TCPServer</a> (int port, int maxMsgSize=1024, int bdp=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#00bff081482e5b8b88866c6280ed4f1d">~TCPServer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#38797e7b50f88497d989201eac42452a">init</a> (int port, int maxMsgSize, int bdp=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#d8b7a73b33a92411a46810477caf5acb">doMessageCycle</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#5643abe77d3c9ee29a0d7a5c3ace2820">getStatusCode</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#349bbfe1d4dcff2c2983b71a62a2191e">getStatusMessage</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#4cd989724362688ef8a96a7d12bcf211">enableIgnoreSigPipe</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#2d8dacef1dc6f7409d64b8da7df38528">disableIgnoreSigPipe</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTCPServer.htm#ae587de263d9648993d83580e4784c4b">receiveAndReply</a> (const char *inMsgBuf, int inMsgLen, int *outMsgLen)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This is the server part of the TCPServer/TCPClient pair. 
<p>
This implementation is the base class that provides server functionality in a client-server relationship over a TCP/IP network. The user must reimplement atleast the <a class="el" href="classTCPServer.htm#ae587de263d9648993d83580e4784c4b">receiveAndReply()</a> function in a derived class in order to have a functional server. This server can listen for upto 20 waiting client connections. This implementation does not do endian conversions to the data being sent/received over the network. Hence you will have jumbled data when communicating between little endian and big endian devices and vice-versa (no problems if both ends use same byte order for data). Note also that this implementation provides a signal handler to ignore SIGPIPE. This will allow server to keep running even after send/recv data on illegal socket resulting from an unexpected client termination.<p>
Use TCPClient/TCPServer when you want to reliably transfer data at slow speeds. Use UDPClient/UDPServer when your primary requirement is speed.<p>
<b>Example Program:</b> <div class="fragment"><pre class="fragment"><span class="comment">//==============================================================================</span>
<span class="comment">// TCPClientServer.t.cpp - Example program for TCPClient/TCPServer</span>
<span class="comment">//</span>
<span class="comment">// Author        : Vilas Kumar Chitrakaran</span>
<span class="comment">//==============================================================================</span>

<span class="preprocessor">#include "TCPClientServer.hpp"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;pthread.h&gt;</span>

<span class="keyword">using namespace </span>std;

<span class="comment">//==============================================================================</span>
<span class="comment">// class MyServer</span>
<span class="comment">//==============================================================================</span>
<span class="keyword">class </span>MyServer : <span class="keyword">public</span> <a class="code" href="classTCPServer.htm">TCPServer</a>
{
 <span class="keyword">public</span>:
  MyServer(<span class="keywordtype">int</span> port, <span class="keywordtype">int</span> maxLen, <span class="keywordtype">int</span> bdp) : <a class="code" href="classTCPServer.htm">TCPServer</a>(port, maxLen, bdp){};
  ~MyServer() {};
  <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTCPServer.htm#ae587de263d9648993d83580e4784c4b">receiveAndReply</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *inMsgBuf, <span class="keywordtype">int</span> inMsgLen, <span class="keywordtype">int</span> *outMsgLen); 
 <span class="keyword">private</span>:
  <span class="keywordtype">char</span> d_outMsgBuf[80];
};


<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classTCPServer.htm#ae587de263d9648993d83580e4784c4b">MyServer::receiveAndReply</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *inMsgBuf, <span class="keywordtype">int</span> inMsgLen, <span class="keywordtype">int</span> *outMsgLen)
{
 cout &lt;&lt; <span class="stringliteral">"MyServer: client said: "</span>;
 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; inMsgLen; i++) cout &lt;&lt; inMsgBuf[i];
 cout &lt;&lt; endl;
 snprintf(d_outMsgBuf, 80, <span class="stringliteral">"%s"</span>, <span class="stringliteral">"Hi there client!!"</span>);
 *outMsgLen = strlen(d_outMsgBuf);
 <span class="keywordflow">return</span> d_outMsgBuf;
}

<span class="comment">//==============================================================================</span>
<span class="comment">// server</span>
<span class="comment">// - handles messages less than 8 bytes long from clients</span>
<span class="comment">//==============================================================================</span>
<span class="keywordtype">void</span> *server(<span class="keywordtype">void</span> *arg)
{
 arg=arg;
 MyServer server(3000, 8, 100);

 server.enableIgnoreSigPipe();
 
 <span class="comment">// check for errors</span>
 <span class="keywordflow">if</span>(server.getStatusCode())
  cout &lt;&lt; <span class="stringliteral">"server: "</span> &lt;&lt; server.getStatusMessage() &lt;&lt; endl;

 <span class="comment">// serve clients</span>
 server.doMessageCycle();
 
 <span class="comment">// check for error</span>
 <span class="keywordflow">if</span>(server.getStatusCode())
  cout &lt;&lt; <span class="stringliteral">"server: "</span> &lt;&lt; server.getStatusMessage() &lt;&lt; endl;
 
 <span class="keywordflow">return</span> NULL;
}


<span class="comment">//==============================================================================</span>
<span class="comment">// client</span>
<span class="comment">// - alternately sends valid and invalid messages to server</span>
<span class="comment">//==============================================================================</span>
<span class="keywordtype">int</span> client()
{
 <span class="keywordtype">char</span> outMsgBuf[80];
 <span class="keywordtype">char</span> inMsgBuf[80];
 <span class="keywordtype">int</span> outMsgLen = 0;
 <span class="keywordtype">int</span> inMsgLen;
 <span class="keywordtype">bool</span> flip = <span class="keyword">false</span>;

 <span class="keyword">struct </span>timeval timeout;
 timeout.tv_sec = 0;
 timeout.tv_usec = 5000; <span class="comment">// 5 ms</span>
 
 <span class="comment">// initialize a client and connect to server</span>
 <a class="code" href="classTCPClient.htm">TCPClient</a> client(<span class="stringliteral">"127.0.0.1"</span>, 3000, timeout, 100);
 <span class="keywordflow">if</span>(client.getStatusCode())
 {
  cout &lt;&lt; <span class="stringliteral">"client: "</span> &lt;&lt; client.getStatusMessage() &lt;&lt; endl;
  <span class="keywordflow">return</span> -1;
 }
 
 client.enableIgnoreSigPipe();
 <span class="keywordtype">int</span> msgNum = 0;
 <span class="keywordflow">while</span>(1)
 {
  <span class="keywordflow">if</span>(msgNum &gt; 100)
   <span class="keywordflow">return</span> 0;

  <span class="comment">// a message</span>
  <span class="keywordflow">if</span>(flip)
  {
   <span class="comment">// improper message (longer than what server can handle)</span>
   snprintf(outMsgBuf, 80, <span class="stringliteral">"%s %d"</span>, <span class="stringliteral">"Hello server"</span>, msgNum);
   outMsgLen = strlen(outMsgBuf);
   flip = !flip;
   cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"client  : Sending invalid (long) client msg. - "</span> &lt;&lt; outMsgBuf &lt;&lt; endl;
  }
  <span class="keywordflow">else</span>
  {
   <span class="comment">// proper message</span>
   snprintf(outMsgBuf, 80, <span class="stringliteral">"%s %d"</span>, <span class="stringliteral">"Hello"</span>, msgNum);
   outMsgLen = strlen(outMsgBuf);
   <span class="comment">//flip = !flip;</span>
   cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"client  : Sending valid client msg. - "</span> &lt;&lt; outMsgBuf &lt;&lt; endl;
  }
  msgNum++;
   
  <span class="comment">// Send a message and receive reply</span>
  <span class="keywordflow">if</span>( client.sendAndReceive(outMsgBuf, outMsgLen, inMsgBuf, 80, &amp;inMsgLen) == -1)
  {
   cout &lt;&lt; <span class="stringliteral">"client  : "</span> &lt;&lt; client.getStatusMessage() &lt;&lt; endl;
   <span class="keywordflow">continue</span>;
  }
 
  <span class="comment">// reply received</span>
  cout &lt;&lt; <span class="stringliteral">"client  : server replied: "</span>;
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; inMsgLen; i++) cout &lt;&lt; inMsgBuf[i];
  cout &lt;&lt; endl;
 }

 <span class="comment">// bye </span>
 <span class="keywordflow">if</span>(client.getStatusCode())
  cout &lt;&lt; <span class="stringliteral">"client  : "</span> &lt;&lt; client.getStatusMessage() &lt;&lt; endl;
 
 <span class="keywordflow">return</span> 0;
}


<span class="comment">//==============================================================================</span>
<span class="comment">// main function</span>
<span class="comment">//==============================================================================</span>
<span class="keywordtype">int</span> main()
{
 pthread_t threadId;
 pthread_create(&amp;threadId, NULL, &amp;server, NULL);
 sleep(1);
 client();
 <span class="keywordflow">return</span> 0;
}
</pre></div> 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="3a5e3cfe42c676ed71f2bc58dcc92bda"></a><!-- doxytag: member="TCPServer::TCPServer" ref="3a5e3cfe42c676ed71f2bc58dcc92bda" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">TCPServer::TCPServer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The default constructor. Does nothing.     </td>
  </tr>
</table>
<a class="anchor" name="5fde4bdcdc8f2bf8c7f548edf7a8260a"></a><!-- doxytag: member="TCPServer::TCPServer" ref="5fde4bdcdc8f2bf8c7f548edf7a8260a" args="(int port, int maxMsgSize=1024, int bdp=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">TCPServer::TCPServer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxMsgSize</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bdp</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes the sever. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port on which the server will wait for clients. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxMsgSize</em>&nbsp;</td><td>Maximum size (bytes) of the receive buffer. Client messages larger than this size are discarded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdp</em>&nbsp;</td><td>This is an advanced option. It allows the user to suggest the bandwidth-delay product in kilo bytes so that socket buffers of optimal sizes can be created. Suppose you are going to receive connections from a machine whose round-trip time (delay between sending a packet and receiving acknowledgement) is 50ms, and the link bandwidth is 100 Mbits per sec. Then your BDP is 100e6 * 50e-3 / 8 = 625 kilo bytes. You can use the 'ping' utility to get an approx. measure for the round-trip time. Set this to 0 to use system defaults. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="00bff081482e5b8b88866c6280ed4f1d"></a><!-- doxytag: member="TCPServer::~TCPServer" ref="00bff081482e5b8b88866c6280ed4f1d" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual TCPServer::~TCPServer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The destructor frees resources.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2d8dacef1dc6f7409d64b8da7df38528"></a><!-- doxytag: member="TCPServer::disableIgnoreSigPipe" ref="2d8dacef1dc6f7409d64b8da7df38528" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int TCPServer::disableIgnoreSigPipe           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this function to disable SIG_PIPE handling. The server will terminate if client terminates <dl compact><dt><b>Returns:</b></dt><dd>0 if no error, else -1 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d8b7a73b33a92411a46810477caf5acb"></a><!-- doxytag: member="TCPServer::doMessageCycle" ref="d8b7a73b33a92411a46810477caf5acb" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void TCPServer::doMessageCycle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function never returns, unless server initialization failed. It constantly checks for any waiting clients. When connected to a client it copies the message from the client into the message buffer and calls <a class="el" href="classTCPServer.htm#ae587de263d9648993d83580e4784c4b">receiveAndReply()</a>. Upon return from user implemented <a class="el" href="classTCPServer.htm#ae587de263d9648993d83580e4784c4b">receiveAndReply()</a> this function will reply back to the client if required ( see <a class="el" href="classTCPServer.htm#ae587de263d9648993d83580e4784c4b">receiveAndReply()</a> ).     </td>
  </tr>
</table>
<a class="anchor" name="4cd989724362688ef8a96a7d12bcf211"></a><!-- doxytag: member="TCPServer::enableIgnoreSigPipe" ref="4cd989724362688ef8a96a7d12bcf211" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int TCPServer::enableIgnoreSigPipe           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this function to ignore SIG_PIPE, and hence save server from terminating due to client termination <dl compact><dt><b>Returns:</b></dt><dd>0 if no error, else -1 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5643abe77d3c9ee29a0d7a5c3ace2820"></a><!-- doxytag: member="TCPServer::getStatusCode" ref="5643abe77d3c9ee29a0d7a5c3ace2820" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int TCPServer::getStatusCode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 on no error, else latest status code. See errno.h for codes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="349bbfe1d4dcff2c2983b71a62a2191e"></a><!-- doxytag: member="TCPServer::getStatusMessage" ref="349bbfe1d4dcff2c2983b71a62a2191e" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const char* TCPServer::getStatusMessage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Latest error status report </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="38797e7b50f88497d989201eac42452a"></a><!-- doxytag: member="TCPServer::init" ref="38797e7b50f88497d989201eac42452a" args="(int port, int maxMsgSize, int bdp=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int TCPServer::init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxMsgSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bdp</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the server. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port number used by the server in listening for clients. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxMsgSize</em>&nbsp;</td><td>Maximum size (bytes) of the receive buffer. Client messages larger than this size are discarded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdp</em>&nbsp;</td><td>Estimated BDP. See constructor for details. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ae587de263d9648993d83580e4784c4b"></a><!-- doxytag: member="TCPServer::receiveAndReply" ref="ae587de263d9648993d83580e4784c4b" args="(const char *inMsgBuf, int inMsgLen, int *outMsgLen)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const char* TCPServer::receiveAndReply           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>inMsgBuf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>inMsgLen</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>outMsgLen</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Re-implement this function in your derived class. This function is called by <a class="el" href="classTCPServer.htm#d8b7a73b33a92411a46810477caf5acb">doMessageCycle()</a> everytime it receives a message from a client. <br>
<hr>
 <ul>
<li>
If return value is set to NULL, the server will not attempt to reply back to the client. </li>
<li>
The message from client is discarded if the receive buffer size (set in the constructor) is not large enough. </li>
</ul>
<hr>
<br>
 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inMsgBuf</em>&nbsp;</td><td>Pointer to buffer containing message from client. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inMsgLen</em>&nbsp;</td><td>Length of the message (bytes) in the above buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outMsgLen</em>&nbsp;</td><td>The length (bytes) of the reply buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL, or a pointer to reply buffer provided by you containing reply message for the client. </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="TCPClientServer_8hpp-source.htm">TCPClientServer.hpp</a></ul>
<hr>
Created for project <code><font color="red"><b>POSIX Utilities Package</b></font></code> on Sat Aug 26 17:12:56 EDT 2006
<br>
 for Vilas Kumar Chitrakaran (cvilas(@)ces.clemson.edu). 
<br>
Documentation generated using <a href=http://www.doxygen.org>Doxygen</a>
.
</body>
</html>
