<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Homography Library: ProjectiveHomography Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.htm"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.htm"><span>Classes</span></a></li>
    <li><a href="files.htm"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.htm"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.htm"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.htm"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>ProjectiveHomography Class Reference</h1><!-- doxytag: class="ProjectiveHomography" -->Homography computation functions.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="Homography_8hpp-source.htm">Homography.hpp</a>&gt;</code>
<p>
<a href="classProjectiveHomography-members.htm">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProjectiveHomography.htm#5280fa34ef6ca8a3899143af84829a7b">ProjectiveHomography</a> (int nFeatures, <a class="el" href="Homography_8hpp.htm#10939b2ed3156d5eacdaa3a347f7f19c">homography_method_t</a> method)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProjectiveHomography.htm#cc450e4622bb54ca30f2382753f3693b">~ProjectiveHomography</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProjectiveHomography.htm#c6911ee9905b8714fb2a00d9461de2d9">compute</a> (MatrixBase&lt;&gt; &amp;p2, MatrixBase&lt;&gt; &amp;p1, Matrix&lt; 3, 3 &gt; &amp;Hpn, VectorBase&lt;&gt; &amp;sc, Matrix&lt; 3, 3 &gt; &amp;dev, int maxItr=100)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Homography computation functions. 
<p>
Homography relates pixel coordinates of coplanar feature points when recorded by a camera from two different poses. If the 3D homogeneous coordinates of a feature point on a plane are q1 = [x1/z1, y1/z1, 1]' and q2 = [x2/z2, y2/z2, 1]' relative to the camera frame at position 1 (I1) and 2 (I2), respectively, we get the following euclidean relationship: <div class="fragment"><pre class="fragment"> q2 = (z1/z2) * He * q1, 
</pre></div> where '(z1/z2)' is called the 'depth ratio', and 'He' is the 'Euclidean homography' defined as: <div class="fragment"><pre class="fragment"> He = (R + (t/d) * transpose(n)).
</pre></div> Here 'R' is the 3x3 rotation matrix that defines the transformation I1 -&gt; I2, 't' is the translation between I1 and I2 defined in frame I2, 'd' and 'n' are the distance, and the unit normal to the plane of feature points, respectively, when camera is at I1. Defined in terms of pixel coordinates p1 (= C * q1) and p2 (= C * q2), for a calibrated camera with 'C' as the internal calibration matrix, we get the following relationship: <div class="fragment"><pre class="fragment"> p2 = (z1/z2) * Hp * p1, 
</pre></div> where Hp is called 'projective homography'. The projective and Euclidean homographies are hence related as follows: <div class="fragment"><pre class="fragment"> Hp = C * He * inverse(C). 
</pre></div> Pay attention to these definitions when you use functions provided in this class. This class primarily provides methods to compute ~projective~ homography from image coordinates of planar feature points, and methods to decompose ~Euclidean~ homography into motion paramters R, t/d and n. Either the least squares technique (fast), or the optimal algorithm (slow) developed by Kanatani et al. can be utilized to compute the homography matrix, if the features are coplanar. If the feature points are non-coplanar, an implementation of a method developed by Ezio Malis is provided that allows computation of homography of a 'virtual' plane. The algorithm given in Faugeras' book and Shastry's book are implemented for decomposition of the homography matrix.<p>
The implementation of optimal homography computation algorithm is not my work. It is a minor adaption of the original implementation by Naoya Ohta and Shimizu Yoshiyuki (1999/2/25) of Computer Science Dept., Gunma University.<p>
References: <ul>
<li>
Least squares algorithm: See R. Sukthankar, R. G. Stockton, and M. D. Mullin, "Smarter Presentations: Exploiting Homography in Camera- Projection Systems," Proc. of ICCV, 2001. </li>
<li>
Kenichi Kanatani optimal algorithm: See K. Kanatani, N. Ohta, and Y. Kanazawa, "Optimal Homography Computation with a Reliability Measure," IEICE Trans. on Information and Systems, Vol. E83-D, No. 7, pp.1369-1374, 2000. </li>
<li>
Malis' virtual parallax algorithm: E. Malis, and F. Chaumette, "2 1/2 D Visual Servoing with Respect to Unknown Objects Through a New Estimation Scheme of Camera Displacement," IJCV, 37(1), 79-97, 2000. </li>
<li>
Faugeras homography decomposition algorithm: See O.Faugeras, Three- Dimensional Computer Vision, The MIT Press, ISBN: 0262061589, page 290. </li>
<li>
Shastry's alternate decomposition algorithm: See Y. Ma, S. Soatto, J. Košecká, and S. Sastry, An Invitation to 3D Vision, Springer-Verlag, ISBN: 0387008934, page 136. </li>
</ul>
<b>Example Program:</b> <div class="fragment"><pre class="fragment"><span class="comment">//==============================================================================</span>
<span class="comment">// Homography.t.cpp - Example program for homography and decomposition</span>
<span class="comment">// Project       : Computer Vision Utilities (cvutils)</span>
<span class="comment">// Author        : Vilas Kumar Chitrakaran (cvilas@ces.clemson.edu)</span>
<span class="comment">//==============================================================================</span>

<span class="preprocessor">#include "<a class="code" href="Homography_8hpp.htm">Homography.hpp</a>"</span>
<span class="preprocessor">#include "QMath/Transform.hpp"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>std;

<span class="comment">//==============================================================================</span>
<span class="comment">// main</span>
<span class="comment">//==============================================================================</span>
<span class="keywordtype">int</span> main()
{
 Matrix&lt;3, 8&gt; p2;            <span class="comment">// pixel coordinates from second frame</span>
 Matrix&lt;3, 8&gt; p1;            <span class="comment">// pixel coordinates from first frame</span>
 <a class="code" href="struct__motion__params.htm">motion_params_t</a> motion[2];  <span class="comment">// recovered motion parameters</span>
 Matrix&lt;3, 3&gt; Hn, Gn;        <span class="comment">// Euclidean and projective Homography</span>
 Matrix&lt;3, 3&gt; A;             <span class="comment">// Camera intrinsic calibration matrix</span>
 Vector&lt;8&gt; scale;            <span class="comment">// scale factor</span>
 
 <span class="comment">// initialize for virtual parallax method</span>
 <a class="code" href="classProjectiveHomography.htm">ProjectiveHomography</a> homography(8, <a class="code" href="Homography_8hpp.htm#cfa45228be0853f4379c8272f0014dcb8aca0e3f1fbf86b297369db21dc6e5d3">e_vp</a>);

 <span class="comment">// initialize camera calibration matrix</span>
 A = 2400, 0, 360, 0, 2400, 240, 0, 0, 1;
 
 <span class="comment">// an example set of pixel coords for 8 non-coplanar features</span>
 p1 = 310, 316, 577, 573, 359, 365, 550, 547,
      45, 288, 267, 58, 44, 287, 271, 53,
      1, 1, 1, 1, 1, 1, 1, 1;
 
 p2 = 315.011, 334.141, 590.244, 575.653, 363.81, 382.601, 564.053, 549.991,
     59.5576, 302.665, 264.716, 58.2838, 56.1194, 298.789, 271.933, 54.8274,
     1, 1, 1, 1, 1, 1, 1, 1;
 
 Matrix&lt;3,3&gt; tmp;
 
 <span class="comment">// compute projective homography</span>
 <span class="keywordflow">if</span>(homography.compute(p2, p1, Gn, scale, tmp) == -1) {
  cerr &lt;&lt; <span class="stringliteral">"Homography determination failed."</span> &lt;&lt; endl;
  <span class="keywordflow">return</span> -1;
 }
 
 <span class="comment">// get Euclidean Homography</span>
 Hn = inverse(A) * Gn * A;
  
 <span class="comment">// decompose homography and recover motion parameters</span>
 <span class="keywordflow">if</span>(<a class="code" href="Homography_8hpp.htm#98c65fd6d68200dc8d9538bdbc79c7c8">decomposeHomography</a>(Hn, motion[0], motion[1]) == -1) {
  cerr &lt;&lt; <span class="stringliteral">"Homography Decomposition failed."</span> &lt;&lt; endl;
  <span class="keywordflow">return</span> -1;
 }

 cout &lt;&lt; <span class="stringliteral">"========= Recovered motion ========="</span> &lt;&lt; endl;
 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {
  cout &lt;&lt; <span class="stringliteral">"========= Solution "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" ========"</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">"Rotation: "</span> &lt;&lt; endl &lt;&lt; motion[i].<a class="code" href="struct__motion__params.htm#6bee8ef3eedcb97de6a62918cbb87498">rotation</a> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">"Scaled Translation: "</span> &lt;&lt; transpose(motion[i].scaledTranslation) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">"normal: "</span> &lt;&lt; transpose(motion[i].normal) &lt;&lt; endl;
 }
 <span class="keywordflow">return</span> 0;
}


</pre></div> <div class="fragment"><pre class="fragment"><span class="comment">//==============================================================================</span>
<span class="comment">// decomposeHomography.t.cpp - Example program for homography decomposition</span>
<span class="comment">// Project       : Computer Vision Utilities (cvutils)</span>
<span class="comment">// Author        : Vilas Kumar Chitrakaran (cvilas@ces.clemson.edu)</span>
<span class="comment">//==============================================================================</span>

<span class="preprocessor">#include "<a class="code" href="Homography_8hpp.htm">Homography.hpp</a>"</span>
<span class="preprocessor">#include "QMath/Transform.hpp"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>std;

Matrix&lt;3,3&gt; computeRotationMatrix(<span class="keywordtype">double</span> r, <span class="keywordtype">double</span> p, <span class="keywordtype">double</span> y);
 <span class="comment">// compute rotation matrix from euler angles</span>

<span class="comment">//======================================================================== </span>
<span class="comment">// main - demonstrates homography decomposition</span>
<span class="comment">//========================================================================  </span>
<span class="keywordtype">int</span> main()
{
 Matrix&lt;3,3&gt; H, R;
 Vector&lt;3&gt; t, n;
 <span class="keywordtype">double</span> d;
 <a class="code" href="struct__motion__params.htm">motion_params_t</a> motion[2];
 
 <span class="comment">// initialize a homography matrix</span>
 R = computeRotationMatrix(M_PI/6.0, 0.0, -M_PI/3.0); <span class="comment">// rotate 30*, 0*, -60*</span>
 t = -0.1, 0, 0; <span class="comment">// translate</span>
 d = 1;     <span class="comment">// distance to feature plane</span>
 n = 1, 0, 0; <span class="comment">// normal to feature plane</span>
 H = R + (1.0/d) * t * transpose(n); <span class="comment">// Euclidean homography</span>
 H = (1.0/H(3,3)) * H;

 <span class="comment">// decompose homography - two solutions</span>
 <a class="code" href="Homography_8hpp.htm#98c65fd6d68200dc8d9538bdbc79c7c8">decomposeHomography</a>(H, motion[0], motion[1]);
 
 cout &lt;&lt; <span class="stringliteral">"==== Actual motion parameters ==== "</span> &lt;&lt; endl;
 cout &lt;&lt; <span class="stringliteral">"Rotation: "</span> &lt;&lt; endl &lt;&lt; R &lt;&lt; endl;
 cout &lt;&lt; <span class="stringliteral">"Scaled Translation: "</span> &lt;&lt; (1.0/d) * transpose(t) &lt;&lt; endl;
 cout &lt;&lt; <span class="stringliteral">"Normal: "</span> &lt;&lt; transpose(n) &lt;&lt; endl;
 
 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {
  cout &lt;&lt; <span class="stringliteral">"========= SHASTRY'S SOLUTION "</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">" ========="</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">"Rotation: "</span> &lt;&lt; endl &lt;&lt; motion[i].<a class="code" href="struct__motion__params.htm#6bee8ef3eedcb97de6a62918cbb87498">rotation</a> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">"Scaled Translation: "</span> &lt;&lt; transpose(motion[i].scaledTranslation) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">"Normal: "</span> &lt;&lt; transpose(motion[i].normal) &lt;&lt; endl;
 }

 <span class="keywordtype">double</span> tmp1, tmp2;
 tmp1 = dotProduct(motion[0].normal,n);
 tmp2 = dotProduct(motion[1].normal,n);
  
 <span class="keywordflow">if</span>(tmp1 &gt; tmp2)
  cout &lt;&lt; <span class="stringliteral">"** Correct solution: 1 **"</span> &lt;&lt; endl &lt;&lt; endl;
 <span class="keywordflow">else</span>
  cout &lt;&lt; <span class="stringliteral">"** Correct solution: 2 **"</span> &lt;&lt; endl &lt;&lt; endl;
 
 <span class="comment">// decompose homography - normal known</span>
 <a class="code" href="Homography_8hpp.htm#98c65fd6d68200dc8d9538bdbc79c7c8">decomposeHomography</a>(H, n, motion[0]);
 cout &lt;&lt; <span class="stringliteral">"========= FAUGERAS' SOLUTION with known normal ========="</span> &lt;&lt; endl;
 cout &lt;&lt; <span class="stringliteral">"Rotation: "</span> &lt;&lt; endl &lt;&lt; motion[0].<a class="code" href="struct__motion__params.htm#6bee8ef3eedcb97de6a62918cbb87498">rotation</a> &lt;&lt; endl;
 cout &lt;&lt; <span class="stringliteral">"Scaled Translation: "</span> &lt;&lt; transpose(motion[0].scaledTranslation) &lt;&lt; endl;
 cout &lt;&lt; <span class="stringliteral">"Normal: "</span> &lt;&lt; transpose(motion[0].normal) &lt;&lt; endl;
 
 <span class="keywordflow">return</span> 0;
}


<span class="comment">//======================================================================== </span>
<span class="comment">// computeRotationMatrix</span>
<span class="comment">//========================================================================  </span>
Matrix&lt;3,3&gt; computeRotationMatrix(<span class="keywordtype">double</span> r, <span class="keywordtype">double</span> p, <span class="keywordtype">double</span> y)
{
 Matrix&lt;3,3&gt; R;
 Transform t;
 t = rpyRotation(r,p,y);
 t.getSubMatrix(1,1,R);
 <span class="keywordflow">return</span> R;
}
</pre></div> 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="5280fa34ef6ca8a3899143af84829a7b"></a><!-- doxytag: member="ProjectiveHomography::ProjectiveHomography" ref="5280fa34ef6ca8a3899143af84829a7b" args="(int nFeatures, homography_method_t method)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ProjectiveHomography::ProjectiveHomography           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>nFeatures</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="Homography_8hpp.htm#10939b2ed3156d5eacdaa3a347f7f19c">homography_method_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>method</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default constructor. Allocates memory required for computations. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nFeatures</em>&nbsp;</td><td>The number of feature points used in the computation of Homography. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>Specify method for computing homography (least squares method, kanatani algorithm, or Malis' virtual parallax method). </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="cc450e4622bb54ca30f2382753f3693b"></a><!-- doxytag: member="ProjectiveHomography::~ProjectiveHomography" ref="cc450e4622bb54ca30f2382753f3693b" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ProjectiveHomography::~ProjectiveHomography           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default destructor frees allocated resources.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c6911ee9905b8714fb2a00d9461de2d9"></a><!-- doxytag: member="ProjectiveHomography::compute" ref="c6911ee9905b8714fb2a00d9461de2d9" args="(MatrixBase&lt;&gt; &amp;p2, MatrixBase&lt;&gt; &amp;p1, Matrix&lt; 3, 3 &gt; &amp;Hpn, VectorBase&lt;&gt; &amp;sc, Matrix&lt; 3, 3 &gt; &amp;dev, int maxItr=100)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int ProjectiveHomography::compute           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">MatrixBase&lt;&gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>MatrixBase&lt;&gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Matrix&lt; 3, 3 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>Hpn</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VectorBase&lt;&gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>sc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Matrix&lt; 3, 3 &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxItr</em> = <code>100</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute the normalized projective homography from homogeneous image coordinates such that p2 = sc * Hpn * p1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p2,p1</em>&nbsp;</td><td>Sets of homogeneous image coordinates arranged as columns of a matrix. IMPORTANT NOTE: If using the virtual parallax method, it will be assumed that the first three columns of this matrix define the virtual plane (input). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Hpn</em>&nbsp;</td><td>The estimated projective homography, normalized by the element at (3,3), i.e., Hpn = [1.0/Hp(3,3)] * Hp. (output) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sc</em>&nbsp;</td><td>The scale factor for every feature point (output). IMPORTANT NOTE: If using the virtual parallax algorithm, only the first three elements of this vector (corresponding to features that define the virtual plane) will have valid values. This is because the scale factor for all other features cannot be accurately determined without using information from decomposition of the homography. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dev</em>&nbsp;</td><td>Deviation matrix, valid only when using the optimal algorithm (output). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxItr</em>&nbsp;</td><td>Maximum number of iteration allowed for convergence, valid only when using the optimal algorithm (input). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>number of iterations if using the optimal algorithm, 1 if using the least squares method, and -1 on error. </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Homography_8hpp-source.htm">Homography.hpp</a></ul>
<hr>
Created for project <code><font color="red"><b>test</b></font></code> on Sat Aug 26 14:52:11 EDT 2006
<br>
 for Vilas Kumar Chitrakaran (cvilas(@)ces.clemson.edu). 
<br>
Documentation generated using <a href=http://www.doxygen.org>Doxygen</a>
.
</body>
</html>
